; docformat = 'rst'
;
;-----------------------------------------------------------------------------
;
; gpuinit2.pro
;
; IDL interface to the GPU library.
;
; Copyright (C) 2008 Tech-X Corporation. All rights reserved.
;
; This file is part of GPULib.
;
; This file may be distributed under the terms of the GNU Affero General Public
; License (AGPL). This file may be distributed and/or modified under the
; terms of the GNU Affero  General Public License version 3 as published by the
; Free Software Foundation.
;
; This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
; WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
;
; Licensees holding valid Tech-X commercial licenses may use this file
; in accordance with the Tech-X Commercial License Agreement provided
; with the Software.
;
; See http://gpulib.txcorp.com/ or email sales@txcorp.com for more information.
;
; This work was in part funded by NASA SBIR Phase II Grant #NNG06CA13C.
;
;-----------------------------------------------------------------------------


;+
; FastGPU IDL library routines.
;
;
; :Examples:
;    For a simple use of the routines, create some IDL variables::
;
;       x = 2 * findgen(10)
;       y = findgen(10) + 5
;
;    Now transfer these IDL variables to the GPU::
;
;       result_gpu = gpuFltarr(10)
;       gpuPutArr, x, x_gpu
;       gpuPutArr, y, y_gpu
;
;    Do an operation::
;
;       gpuAdd, x_gpu, y_gpu, result_gpu
;
;    Finally get the results back from the GPU and print the result::
;
;       gpuGetArr, result_gpu, result
;       print, result
;-


;
; general purpose definitions
;


;+
; Creates a variable on the GPU that can be manipulated by the FastGPU library
; routines.
;
; :Returns: a blank { GPUHANDLE } structure
;-
function gpuGetHandle
  return, { GPUHANDLE }
end


;
; memory mamangement routines
;

;+
; Free resource on GPU held by given variable(s).
;
; :Params:
;    x_gpu : in, required, type=scalar or array of { GPUHANDLE }
;       GPU variable(s) to free
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuFree, x_gpu, ERROR=err

  err = 0

  nVars = n_elements(x_gpu)
  if (nVars gt 1) then begin
    for i = 0L, nVars - 1L do gpuFree, x_gpu[i]
  endif

  if (!gpu.mode eq 0) then begin
    ptr_free, x_gpu.data
  endif else begin
    err = cudaFree(x_gpu.handle)
  endelse

  ; undefine the variable x_gpu
  dummy = temporary(x_gpu)
end


;+
; This routine creates an IDL structure representing an array on the GPU
; that other FastGPU library routines can use.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    NOZERO : in, optional, type=boolean
;       Normally, gpuFltarr setts every element of the allocated array to
;       zero. If set, this keyword prevents zeroing the elements, running
;       slightly faster.
;    VALUE : in, optional, type=float
;       initialization value for array.
;    INDEX : in, optional, type=boolean
;       initialize array elements to their indices
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuMake_Array, nx, ny, $
             COMPLEX=complex, DCOMPLEX=dcomplex, FLOAT=float, DOUBLE=double, $
             TYPE=type,$
             NOZERO=nozero, VALUE=value, INDEX=index, ERROR=err

  err = 0
  res = gpuGetHandle()                  ; get the gpu handle
  
  type_id = 4

  if keyword_set(TYPE) then type_id = type 
  if keyword_set(FLOAT) then type_id =  4 
  if keyword_set(DOUBLE) then type_id = 5 
  if keyword_set(COMPLEX) then type_id = 6 
  if keyword_set(DCOMPLEX) then type_id = 9 
 
  case type_id of
    4:  begin
	  type_val = float(1.)
	  nbytes = 4L
        end
    5:  begin
          type_val = double(1.)
          nbytes = 8L
        end
    6:  begin
          type_val = complex(1.)
          nbytes  = 2 * 4L
        end 
    9:  begin
          type_val = dcomplex(1.)
          nbytes = 2 * 8L
        end
  endcase

  res.type = type_id
 
  case n_params() of
    1 :  begin
           ln = long(nx)
           res.n_elements    = long(nx)
           res.n_dimensions  = 1L
           res.dimensions[0] = long(nx)
           res.dimensions[1] = 1L
         end
    2 :  begin
           ln = long(nx) * long(ny)
           res.n_elements    = long(nx) * long(ny)
           res.n_dimensions  = 2L
           res.dimensions[0] = long(nx)
           res.dimensions[1] = long(ny)
         end
  endcase

  if (!gpu.mode eq 0) then begin
    if n_params() eq 1 then begin
      res.data = ptr_new(make_array(nx, $
                  COMPLEX=complex, DCOMPLEX=dcomplex, $
                  FLOAT=float, DOUBLE=double,$
                  NOZERO=nozero, VALUE=value, INDEX=index))
    endif else begin
      res.data = ptr_new(make_array(nx, ny, $
                  COMPLEX=complex, DCOMPLEX=dcomplex, $
                  FLOAT=float, DOUBLE=double,$
                  NOZERO=nozero, VALUE=value, INDEX=index))
    endelse
    return, res
  endif

  n  = ln * nbytes
  err = cudaMalloc(handle, n)

  if ~keyword_set(NOZERO) then begin
     if ~keyword_set(value) then value = type_val * 0.
     if value eq 0. then begin
        err = cudaMemset(handle, 0L, n)
     end else begin
        err = cudaMemset(handle, 0L, n)

        case res.type of
           4 : err = gpuAddFAT(ln, float(0), handle, float(0), handle, $
                              float(value), handle)
           5 : err = gpuAddDAT(ln, double(0), handle, double(0), handle, $
                              double(value), handle)
           6 : err = gpuAddCAT(ln, complex(0), handle, complex(0), handle, $
                              complex(value), handle)
           9 : err = gpuAddZAT(ln, dcomplex(0), handle, dcomplex(0), $
                              handle, dcomplex(value), handle)
           else: 
        endcase
     endelse
  endif

  if keyword_set(INDEX) then begin 
     case res.type of 
           4 : err = gpuFindgenF(ln, handle)
           5 : err = gpuDindgenD(ln, handle)
           6 : err = gpuCindgenC(ln, handle)
           9 : err = gpuDCindgenZ(ln, handle)
      endcase 
  endif
  res.handle = handle
  return, res
end


;+
; This routine creates an IDL structure representing a float array on the GPU
; that other FastGPU library routines can use.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    NOZERO: in, optional, type=boolean
;       Normally, gpuFltarr setts every element of the allocated array to
;       zero. If set, this keyword prevents zeroing the elements, running
;       slightly faster.
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuFltarr, nx, ny, NOZERO=nozero, ERROR=err

  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, NOZERO=nozero, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, NOZERO=nozero, ERROR=err)
        end
  endcase

  return, res
end

;+
; This routine creates an IDL structure representing a double array on the GPU
; that other FastGPU library routines can use.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    NOZERO: in, optional, type=boolean
;       Normally, gpuDblarr setts every element of the allocated array to
;       zero. If set, this keyword prevents zeroing the elements, running
;       slightly faster.
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuDblarr, nx, ny, NOZERO=nozero, ERROR=err

  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /DOUBLE, NOZERO=nozero, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /DOUBLE, NOZERO=nozero, ERROR=err)
        end
  endcase

  return, res
end

;+
; This routine creates an IDL structure representing a complex array on the GPU
; that other FastGPU library routines can use.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    NOZERO: in, optional, type=boolean
;       Normally, gpuComplxarr setts every element of the allocated array to
;       zero. If set, this keyword prevents zeroing the elements, running
;       slightly faster.
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuComplexarr, nx, ny, NOZERO=nozero, ERROR=err

  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /COMPLEX, NOZERO=nozero, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /COMPLEX, NOZERO=nozero, ERROR=err)
        end
  endcase

  return, res
end

;+
; This routine creates an IDL structure representing a double precision 
; complex array on the GPU that other FastGPU library routines can use.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    NOZERO: in, optional, type=boolean
;       Normally, gpuDcomplxarr setts every element of the allocated array to
;       zero. If set, this keyword prevents zeroing the elements, running
;       slightly faster.
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuDcomplexarr, nx, ny, NOZERO=nozero, ERROR=err

  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /DCOMPLEX, NOZERO=nozero, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /DCOMPLEX, NOZERO=nozero, ERROR=err)
        end
  endcase

  return, res
end


;+
; This routine creates an IDL structure representing a float array on the GPU
; that other FastGPU library routines can use and initializes its elements
; to the array index.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuFindgen, nx, ny, ERROR=err
  
  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /INDEX, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /INDEX, ERROR=err)
        end
  endcase

  return, res

end

;+
; This routine creates an IDL structure representing a double array on the GPU
; that other FastGPU library routines can use and initializes its elements
; to the array index.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuDindgen, nx, ny, ERROR=err

  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /DOUBLE, /INDEX, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /DOUBLE, /INDEX, ERROR=err)
        end
  endcase

  return, res

end

;+
; This routine creates an IDL structure representing a complex array on the GPU
; that other FastGPU library routines can use and initializes its elements
; to the array index.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuCindgen, nx, ny, ERROR=err
  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /COMPLEX, /INDEX, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /COMPLEX, /INDEX, ERROR=err)
        end
  endcase

  return, res

end

;+
; This routine creates an IDL structure representing a double precision 
; complex array on the GPU that other FastGPU library routines can use and 
; initializes its elements to the array index.
;
; :Returns: structure
;
; :Params:
;    nx : in, required, type=integer
;       size of first dimenion
;    ny : in, optional, type=integer
;       size of second dimenion, if present
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuDcindgen, nx, ny, ERROR=err

  case n_params() of
    1 : begin
          res = gpuMake_Array(nx, /DCOMPLEX, /INDEX, ERROR=err)
        end
    2 : begin
          res = gpuMake_Array(nx, ny, /DCOMPLEX, /INDEX, ERROR=err)
        end
  endcase

  return, res

end



;
; data transfer routines
;


;+
; Transfer IDL variables to the GPU.
;
; :Params:
;    x : in, required, type=any
;       normal IDL variable to send to the GPU
;    x_gpu : in, out, optional, type={ GPUHANDLE }
;       GPU variable to fill of the same size/type as x
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuPutArr, x, x_gpu, ERROR=err
  on_error, 2
  err = 0
  nx = n_elements(x)

; we can now live with other types than float
;  if size(x, /type) ne size(float(1.), /type) then begin
;    message, level=-1, 'gpuPutArr: Incompatible types'
;  endif

  ; x_gpu not defined
  if n_elements(x_gpu) eq 0 then begin
    x_gpu = gpuMake_Array(nx, type=size(x, /type))
    x_gpu.n_dimensions = (size(x, /structure)).n_dimensions
    x_gpu.dimensions  = ((size(x, /structure)).dimensions)[0:1]
  endif

  if nx ne x_gpu.n_elements then begin
    gpuFree, x_gpu
    x_gpu = gpuMake_Array(nx, type=size(x, /type))
    x_gpu.n_dimensions = (size(x, /structure)).n_dimensions
    x_gpu.dimensions  = ((size(x, /structure)).dimensions)[0:1]
  endif

  if (!gpu.mode eq 0) then begin
    *x_gpu.data = x
  endif else begin
    case x_gpu.type  of
      4 : nbytes = 4L 
      5 : nbytes = 2 * 4L 
      6 : nbytes = 2 * 4L
      9 : nbytes = 2 * 2 * 4L
  end
    err = cublasSetVector(nx, nbytes, x, 1L, x_gpu.handle, 1L)
  endelse
end


;+
; Transfer GPU variables to IDL.
;
; :Params:
;    x_gpu : in, optional, type={ GPUHANDLE }
;       GPU variable
;    x : in, out, required, type=any
;       pre-allocated normal IDL variable of the same type/size as x_gpu
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuGetArr, x_gpu, x, ERROR=err
  on_error, 2

  err = 0
  nx = x_gpu.n_elements

  if size(x, /type) eq 0 then begin
    x = make_array(nx, type=x_gpu.type, /NOZERO)
;    x = fltarr(nx, /NOZERO)
    if x_gpu.n_dimensions eq 2 then x = reform(x, x_gpu.dimensions)
    new_alloc = 1
  endif

;  if size(x, /type) ne size(float(1.), /type) then begin
;    if n_elements(new_alloc) ne 0 then dummy = temporary(x)
;    message, level=-1, 'getGetArr: Incompatible types'
;  endif

  if size(x, /type) ne x_gpu.type then x = 0

  if n_elements(x) ne nx then begin
    x = make_array(nx, type=x_gpu.type, /NOZERO)
    ;x = fltarr(nx, /NOZERO)
    x = reform(x, x_gpu.dimensions)
  endif

  if (!gpu.mode eq 0) then begin
    x = *x_gpu.data
  endif else begin
    case x_gpu.type  of
      4 : nbytes = 4L 
      5 : nbytes = 2 * 4L 
      6 : nbytes = 2 * 4L
      9 : nbytes = 2 * 2 * 4L
  end
    err = cublasGetVector(nx, nbytes, x_gpu.handle, 1L, x, 1L)
  endelse
end


;
; binary vector operations
;


;+
; Add two vectors. There are two forms for the arguments to this
; routine::
;
;   p3 = p1 + p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = p1 * p2 + p3 * p4 + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuAdd, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1,/type) ne 8 then p1_type=size(p1,/type) else p1_type=p1.type
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         i=intarr(2)
         i[0]=p1_type
         i[1]=p2_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, float(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),y else y=p2
               end
           5 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, double(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),y else y=p2                 
               end
           6 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, complex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),y else y=p2
               end
           9 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, dcomplex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),y else y=p2
               end
           else: message, level=-1, 'gpuAdd: unknown argument type'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif  
         if size(p3,/type) ne 8 then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p3,/type) eq 8 then begin
           if p3.type ne result_type then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p3.n_elements) then begin
           msg=(x.n_elements ne y.n_elements) ? 'input' : 'output' 
           if size(p1,/type) ne 8 then gpuFree, x
           if size(p2,/type) ne 8 then gpuFree, y
           if size(p3,/type) ne 8 then gpuFree, p3
           message, level=-1, 'gpuAdd: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p3.data = *x.data + *y.data
         endif else begin
           case result_type of
             4 : err=gpuAddF(x.n_elements,x.handle,y.handle,p3.handle)
             5 : err=gpuAddD(x.n_elements,x.handle,y.handle,p3.handle)
             6 : err=gpuAddC(x.n_elements,x.handle,y.handle,p3.handle)
             9 : err=gpuAddZ(x.n_elements,x.handle,y.handle,p3.handle)
           endcase
         endelse
         if size(p1,/type) ne 8 then gpuFree, x
         if size(p2,/type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         if size(p4,/type) ne 8 then p4_type=size(p4,/type) else p4_type=p4.type
         i=intarr(2)
         i[0]=p2_type
         i[1]=p4_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, float(p4),y else y=p4
               end
           5 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, double(p4),y else y=p4
               end
           6 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, complex(p4),y else y=p4
               end
           9 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, dcomplex(p4),y else y=p4
               end
           else: message, level=-1, 'gpuAdd: incorrect number of arguments'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p6,/type) ne 8 then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p6,/type) eq 8 then begin
           if p6.type ne result_type then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p6.n_elements) then begin
           if size(p2, /type) ne 8 then gpuFree, x
           if size(p4, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuAdd: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * *x.data + p3 * *y.data + p5
         endif else begin
           case result_type of
             4 : err=gpuAddFAT(x.n_elements,float(p1),x.handle,float(p3),y.handle,float(p5),p6.handle)
             5 : err=gpuAddDAT(x.n_elements,double(p1),x.handle,double(p3),y.handle,double(p5),p6.handle)
             6 : err=gpuAddCAT(x.n_elements,complex(p1),x.handle,complex(p3),y.handle,complex(p5),p6.handle)
             9 : err=gpuAddZAT(x.n_elements,dcomplex(p1),x.handle,dcomplex(p3),y.handle,dcomplex(p5),p6.handle)
           endcase
         endelse
         if size(p2,/type) ne 8 then gpuFree, x
         if size(p4,/type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuAdd: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then err OR= cudaThreadSynchronize()
end


;+
; Subtracts two vectors. There are two forms for the arguments to this
; routine::
;
;   p3 = p1 - p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = p1 * p2 - p3 * p4 + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuSub, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1,/type) ne 8 then p1_type=size(p1,/type) else p1_type=p1.type
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         i=intarr(2)
         i[0]=p1_type
         i[1]=p2_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, float(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),y else y=p2
               end
           5 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, double(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),y else y=p2                 
               end
           6 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, complex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),y else y=p2
               end
           9 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, dcomplex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),y else y=p2
               end
           else: message, level=-1, 'gpuSub: unknown argument type'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p3,/type) ne 8 then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p3,/type) eq 8 then begin
           if p3.type ne result_type then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p3.n_elements) then begin
           msg=(x.n_elements ne y.n_elements) ? 'input' : 'output' 
           if size(p1,/type) ne 8 then gpuFree, x
           if size(p2,/type) ne 8 then gpuFree, y
           if size(p3,/type) ne 8 then gpuFree, p3
           message, level=-1, 'gpuSub: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p3.data = *x.data + *y.data
         endif else begin
           case result_type of
             4 : err=gpuSubF(x.n_elements,x.handle,y.handle,p3.handle)
             5 : err=gpuSubD(x.n_elements,x.handle,y.handle,p3.handle)
             6 : err=gpuSubC(x.n_elements,x.handle,y.handle,p3.handle)
             9 : err=gpuSubZ(x.n_elements,x.handle,y.handle,p3.handle)
           endcase
         endelse
         if size(p1,/type) ne 8 then gpuFree, x
         if size(p2,/type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         if size(p4,/type) ne 8 then p4_type=size(p4,/type) else p4_type=p4.type
         i=intarr(2)
         i[0]=p2_type
         i[1]=p4_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, float(p4),y else y=p4
               end
           5 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, double(p4),y else y=p4
               end
           6 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, complex(p4),y else y=p4
               end
           9 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, dcomplex(p4),y else y=p4
               end
           else: message, level=-1, 'gpuSub: incorrect number of arguments'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p6,/type) ne 8 then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p6,/type) eq 8 then begin
           if p6.type ne result_type then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p6.n_elements) then begin
           if size(p2, /type) ne 8 then gpuFree, x
           if size(p4, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuSub: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * *x.data + p3 * *y.data + p5
         endif else begin
           case result_type of
             4 : err=gpuSubFAT(x.n_elements,float(p1),x.handle,float(p3),y.handle,float(p5),p6.handle)
             5 : err=gpuSubDAT(x.n_elements,double(p1),x.handle,double(p3),y.handle,double(p5),p6.handle)
             6 : err=gpuSubCAT(x.n_elements,complex(p1),x.handle,complex(p3),y.handle,complex(p5),p6.handle)
             9 : err=gpuSubZAT(x.n_elements,dcomplex(p1),x.handle,dcomplex(p3),y.handle,dcomplex(p5),p6.handle)
           endcase
         endelse
         if size(p2,/type) ne 8 then gpuFree, x
         if size(p4,/type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuSub: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Multiplies two vectors. There are two forms for the arguments to this
; routine::
;
;   p3 = p1 * p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = p1 * p2 * p3 * p4 + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuMult, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1,/type) ne 8 then p1_type=size(p1,/type) else p1_type=p1.type
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         i=intarr(2)
         i[0]=p1_type
         i[1]=p2_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, float(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),y else y=p2
               end
           5 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, double(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),y else y=p2                 
               end
           6 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, complex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),y else y=p2
               end
           9 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, dcomplex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),y else y=p2
               end
           else: message, level=-1, 'gpuMult: unknown argument type'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p3,/type) ne 8 then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p3,/type) eq 8 then begin
           if p3.type ne result_type then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p3.n_elements) then begin
           msg=(x.n_elements ne y.n_elements) ? 'input' : 'output' 
           if size(p1,/type) ne 8 then gpuFree, x
           if size(p2,/type) ne 8 then gpuFree, y
           if size(p3,/type) ne 8 then gpuFree, p3
           message, level=-1, 'gpuMult: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p3.data = *x.data + *y.data
         endif else begin
           case result_type of
             4 : err=gpuMultF(x.n_elements,x.handle,y.handle,p3.handle)
             5 : err=gpuMultD(x.n_elements,x.handle,y.handle,p3.handle)
             6 : err=gpuMultC(x.n_elements,x.handle,y.handle,p3.handle)
             9 : err=gpuMultZ(x.n_elements,x.handle,y.handle,p3.handle)
           endcase
         endelse
         if size(p1,/type) ne 8 then gpuFree, x
         if size(p2,/type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         if size(p4,/type) ne 8 then p4_type=size(p4,/type) else p4_type=p4.type
         i=intarr(2)
         i[0]=p2_type
         i[1]=p4_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, float(p4),y else y=p4
               end
           5 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, double(p4),y else y=p4
               end
           6 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, complex(p4),y else y=p4
               end
           9 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, dcomplex(p4),y else y=p4
               end
           else: message, level=-1, 'gpuMult: incorrect number of arguments'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p6,/type) ne 8 then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p6,/type) eq 8 then begin
           if p6.type ne result_type then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p6.n_elements) then begin
           if size(p2, /type) ne 8 then gpuFree, x
           if size(p4, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuMult: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * *x.data + p3 * *y.data + p5
         endif else begin
           case result_type of
             4 : err=gpuMultFAT(x.n_elements,float(p1),x.handle,float(p3),y.handle,float(p5),p6.handle)
             5 : err=gpuMultDAT(x.n_elements,double(p1),x.handle,double(p3),y.handle,double(p5),p6.handle)
             6 : err=gpuMultCAT(x.n_elements,complex(p1),x.handle,complex(p3),y.handle,complex(p5),p6.handle)
             9 : err=gpuMultZAT(x.n_elements,dcomplex(p1),x.handle,dcomplex(p3),y.handle,dcomplex(p5),p6.handle)
           endcase
         endelse
         if size(p2,/type) ne 8 then gpuFree, x
         if size(p4,/type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuMult: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Divides two vectors. There are two forms for the arguments to this
; routine::
;
;   p3 = p1 / p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = p1 * p2 / p3 * p4 + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuDiv, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0
; NEED TO CHECK FOR DIVIDE BY ZERO ERROR IN THE FOLLOWING CODE
  case n_params() of
    3: begin
         if size(p1,/type) ne 8 then p1_type=size(p1,/type) else p1_type=p1.type
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         i=intarr(2)
         i[0]=p1_type
         i[1]=p2_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, float(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),y else y=p2
               end
           5 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, double(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),y else y=p2                 
               end
           6 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, complex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),y else y=p2
               end
           9 : begin
                 if size(p1,/type) ne 8 then gpuPutArr, dcomplex(p1),x else x=p1
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),y else y=p2
               end
           else: message, level=-1, 'gpuDiv: unknown argument type'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p3,/type) ne 8 then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p3,/type) eq 8 then begin
           if p3.type ne result_type then p3=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p3.n_elements) then begin
           msg=(x.n_elements ne y.n_elements) ? 'input' : 'output' 
           if size(p1,/type) ne 8 then gpuFree, x
           if size(p2,/type) ne 8 then gpuFree, y
           if size(p3,/type) ne 8 then gpuFree, p3
           message, level=-1, 'gpuDiv: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p3.data = *x.data + *y.data
         endif else begin
           case result_type of
             4 : err=gpuDivF(x.n_elements,x.handle,y.handle,p3.handle)
             5 : err=gpuDivD(x.n_elements,x.handle,y.handle,p3.handle)
             6 : err=gpuDivC(x.n_elements,x.handle,y.handle,p3.handle)
             9 : err=gpuDivZ(x.n_elements,x.handle,y.handle,p3.handle)
           endcase
         endelse
         if size(p1,/type) ne 8 then gpuFree, x
         if size(p2,/type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2,/type) ne 8 then p2_type=size(p2,/type) else p2_type=p2.type
         if size(p4,/type) ne 8 then p4_type=size(p4,/type) else p4_type=p4.type
         i=intarr(2)
         i[0]=p2_type
         i[1]=p4_type
         result_type=max(i)
         if (max(i) eq 6) and (min(i) eq 5) then result_type=9
         case result_type of
           4 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, float(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, float(p4),y else y=p4
               end
           5 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, double(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, double(p4),y else y=p4
               end
           6 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, complex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, complex(p4),y else y=p4
               end
           9 : begin
                 if size(p2,/type) ne 8 then gpuPutArr, dcomplex(p2),x else x=p2
                 if size(p4,/type) ne 8 then gpuPutArr, dcomplex(p4),y else y=p4
               end
           else: message, level=-1, 'gpuDiv: incorrect number of arguments'
         endcase
         if x.type ne result_type then begin
           x_tmp=x
           x=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, x_tmp,x,in_type=x_tmp.type,out_type=result_type
           gpuFree, x_tmp
         endif
         if y.type ne result_type then begin
           y_tmp=x
           y=gpuMake_Array(y.n_elements,TYPE=result_type,/NOZERO)
           ;gpuConvert, y_tmp,y,in_type=y_tmp.type,out_type=result_type
           gpuFree, y_tmp
         endif
         if size(p6,/type) ne 8 then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO) 
         if size(p6,/type) eq 8 then begin
           if p6.type ne result_type then p6=gpuMake_Array(x.n_elements,TYPE=result_type,/NOZERO)
         endif
         if (x.n_elements ne y.n_elements) or (x.n_elements ne p6.n_elements) then begin
           if size(p2, /type) ne 8 then gpuFree, x
           if size(p4, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuDiv: '+msg+' vector length missmatch'
         endif
         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * *x.data + p3 * *y.data + p5
         endif else begin
           case result_type of
             4 : err=gpuDivFAT(x.n_elements,float(p1),x.handle,float(p3),y.handle,float(p5),p6.handle)
             5 : err=gpuDivDAT(x.n_elements,double(p1),x.handle,double(p3),y.handle,double(p5),p6.handle)
             6 : err=gpuDivCAT(x.n_elements,complex(p1),x.handle,complex(p3),y.handle,complex(p5),p6.handle)
             9 : err=gpuDivZAT(x.n_elements,dcomplex(p1),x.handle,dcomplex(p3),y.handle,dcomplex(p5),p6.handle)
           endcase
         endelse
         if size(p2,/type) ne 8 then gpuFree, x
         if size(p4,/type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuDiv: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
;  Compares two vectors for LT and stores the result as float-boolean
;
;   p3 = p1 LT p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = (p1 * p2) LT (p3 * p4) + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLt, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then gpuPutArr, p2, y else y = p2
         if size(p3, /type) ne 8 then p3 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or  $
            (x.n_elements ne p3.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p3, /type) ne 8 then gpuFree, p3
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output' 
           message, level=-1, 'gpuLt: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p3.data = float(*x.data LT *y.data)
         endif else begin
           err = gpuLtF(x.n_elements, x.handle, y.handle, p3.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
         if size(p2, /type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2, /type) ne 8 then gpuPutArr, p2, x else x = p2
         if size(p4, /type) ne 8 then gpuPutArr, p4, y else y = p4
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or $
            (x.n_elements ne p6.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuLt: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = float((p1 * *x.data) LT (p3 * *y.data) + p5)
         endif else begin
           err = gpuLtFAT(x.n_elements, float(p1), x.handle, $
                           float(p3), y.handle, float(p5), p6.handle)
         endelse
         if size(p2, /type) ne 8 then gpuFree, x
         if size(p4, /type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuLt: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then $
                err OR= cudaThreadSynchronize()
end

;+
;  Compares two vectors for GT and stores the result as float-boolean
;
;   p3 = p1 GT p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = (p1 * p2) GT (p3 * p4) + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuGt, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then gpuPutArr, p2, y else y = p2
         if size(p3, /type) ne 8 then p3 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or  $
            (x.n_elements ne p3.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p3, /type) ne 8 then gpuFree, p3
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output' 
           message, level=-1, 'gpuGt: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p3.data = float(*x.data GT *y.data)
         endif else begin
           err = gpuGtF(x.n_elements, x.handle, y.handle, p3.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
         if size(p2, /type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2, /type) ne 8 then gpuPutArr, p2, x else x = p2
         if size(p4, /type) ne 8 then gpuPutArr, p4, y else y = p4
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or $
            (x.n_elements ne p6.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuGt: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = float((p1 * *x.data) GT (p3 * *y.data) + p5)
         endif else begin
           err = gpuGtFAT(x.n_elements, float(p1), x.handle, $
                           float(p3), y.handle, float(p5), p6.handle)
         endelse
         if size(p2, /type) ne 8 then gpuFree, x
         if size(p4, /type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuGt: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then $
                err OR= cudaThreadSynchronize()
end

;+
;  Compares two vectors for LE and stores the result as float-boolean
;
;   p3 = p1 LE p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = (p1 * p2) LE (p3 * p4) + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLe, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then gpuPutArr, p2, y else y = p2
         if size(p3, /type) ne 8 then p3 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or  $
            (x.n_elements ne p3.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p3, /type) ne 8 then gpuFree, p3
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output' 
           message, level=-1, 'gpuLe: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p3.data = float(*x.data LE *y.data)
         endif else begin
           err = gpuLtEqF(x.n_elements, x.handle, y.handle, p3.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
         if size(p2, /type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2, /type) ne 8 then gpuPutArr, p2, x else x = p2
         if size(p4, /type) ne 8 then gpuPutArr, p4, y else y = p4
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or $
            (x.n_elements ne p6.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuLe: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = float((p1 * *x.data) LE (p3 * *y.data) + p5)
         endif else begin
           err = gpuLeFAT(x.n_elements, float(p1), x.handle, $
                           float(p3), y.handle, float(p5), p6.handle)
         endelse
         if size(p2, /type) ne 8 then gpuFree, x
         if size(p4, /type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuLe: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then $
                err OR= cudaThreadSynchronize()
end

;+
;  Compares two vectors for GE and stores the result as float-boolean
;
;   p3 = p1 GE p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = (p1 * p2) GE (p3 * p4) + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuGe, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then gpuPutArr, p2, y else y = p2
         if size(p3, /type) ne 8 then p3 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or  $
            (x.n_elements ne p3.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p3, /type) ne 8 then gpuFree, p3
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output' 
           message, level=-1, 'gpuGe: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p3.data = float(*x.data GE *y.data)
         endif else begin
           err = gpuGtEqF(x.n_elements, x.handle, y.handle, p3.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
         if size(p2, /type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2, /type) ne 8 then gpuPutArr, p2, x else x = p2
         if size(p4, /type) ne 8 then gpuPutArr, p4, y else y = p4
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or $
            (x.n_elements ne p6.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuGe: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = float((p1 * *x.data) GE (p3 * *y.data) + p5)
         endif else begin
           err = gpuGeFAT(x.n_elements, float(p1), x.handle, $
                           float(p3), y.handle, float(p5), p6.handle)
         endelse
         if size(p2, /type) ne 8 then gpuFree, x
         if size(p4, /type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuGe: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then $
                err OR= cudaThreadSynchronize()
end

;+
;  Compares two vectors for EQ and stores the result as float-boolean
;
;   p3 = p1 EQ p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = (p1 * p2) EQ (p3 * p4) + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuEq, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then gpuPutArr, p2, y else y = p2
         if size(p3, /type) ne 8 then p3 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or  $
            (x.n_elements ne p3.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p3, /type) ne 8 then gpuFree, p3
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output' 
           message, level=-1, 'gpuEq: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p3.data = float(*x.data EQ *y.data)
         endif else begin
           err = gpuEqF(x.n_elements, x.handle, y.handle, p3.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
         if size(p2, /type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2, /type) ne 8 then gpuPutArr, p2, x else x = p2
         if size(p4, /type) ne 8 then gpuPutArr, p4, y else y = p4
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or $
            (x.n_elements ne p6.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuEq: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = float((p1 * *x.data) EQ (p3 * *y.data) + p5)
         endif else begin
           err = gpuEqFAT(x.n_elements, float(p1), x.handle, $
                           float(p3), y.handle, float(p5), p6.handle)
         endelse
         if size(p2, /type) ne 8 then gpuFree, x
         if size(p4, /type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuEq: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then $
                err OR= cudaThreadSynchronize()
end

;+
;  Compares two vectors for NE and stores the result as float-boolean
;
;   p3 = p1 NE p2
;
; where p1, p2 are { GPUHANDLE } or float and p3 is { GPUHANDLE }.
; Or::
;
;   p6 = (p1 * p2) NE (p3 * p4) + p5
;
; where p2, p4 are { GPUHANDLE } or float , p6 is { GPUHANDLE }
; and p1, p3, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, required, type={ GPUHANDLE }
;    p3 : in, out, required, type=float or { GPUHANDLE }
;    p4 : in, optional, type={ GPUHANDLE }
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuNe, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then gpuPutArr, p2, y else y = p2
         if size(p3, /type) ne 8 then p3 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or  $
            (x.n_elements ne p3.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p3, /type) ne 8 then gpuFree, p3
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output' 
           message, level=-1, 'gpuNe: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p3.data = float(*x.data NE *y.data)
         endif else begin
           err = gpuNeF(x.n_elements, x.handle, y.handle, p3.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
         if size(p2, /type) ne 8 then gpuFree, y
       end
    6: begin
         if size(p2, /type) ne 8 then gpuPutArr, p2, x else x = p2
         if size(p4, /type) ne 8 then gpuPutArr, p4, y else y = p4
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if (x.n_elements ne y.n_elements) or $
            (x.n_elements ne p6.n_elements) then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, y
           if size(p6, /type) ne 8 then gpuFree, p6
           msg = (x.n_elements ne y.n_elements) ? 'input' : 'output'
           message, level=-1, 'gpuNe: '+msg+' vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = float((p1 * *x.data) NE (p3 * *y.data) + p5)
         endif else begin
           err = gpuNeFAT(x.n_elements, float(p1), x.handle, $
                           float(p3), y.handle, float(p5), p6.handle)
         endelse
         if size(p2, /type) ne 8 then gpuFree, x
         if size(p4, /type) ne 8 then gpuFree, y
       end
    else: message, level=-1, 'gpuEq: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && (!gpu.mode ne 0)) then $
                err OR= cudaThreadSynchronize()
end

;
; unary vector operations
;


;+
; Takes the square root of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = sqrt(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * sqrt(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuSqrt, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuSqrt: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = sqrt(*x.data)
         endif else begin
           err = gpuSqrtF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuSqrt: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * sqrt(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuSqrtFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuSqrt: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the exponential of the argument. There are two forms for the arguments
; to this routine::
;
;   p2 = exp(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * exp(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuExp, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuExp: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = exp(*x.data)
         endif else begin
           err = gpuExpF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuExp: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * exp(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuExpFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuExp: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Raise 2.0 to the power of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = 2.0 ^ p1
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * 2.0 ^ (p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuExp2, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuExp2: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = 2.0 ^ (*x.data)
         endif else begin
           err = gpuExp2F(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuExp2: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * 2.0^(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuExp2FAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuExp2: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Raise 10.0 to the power of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = 10.0 ^ p1
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * 10.0 ^ (p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuExp10, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuExp10: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = 10.^(*x.data)
         endif else begin
           err = gpuExp10F(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuExp10: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * 10.0^(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuExp10FAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuExp10: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Take the natural logarithm of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = alog(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * alog(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLog, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLog: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = alog(*x.data)
         endif else begin
           err = gpuLogF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLog: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * alog(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuLogFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLog: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Take the base 2 logarithm of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = alog(p1) / alog(2)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * alog(p2 * p3 + p4) / alog(2) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLog2, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLog2: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = alog(*x.data) / alog(2.0)
         endif else begin
           err = gpuLog2F(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
     end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLog2: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * alog(p2 * *x.data + p4)/alog(2.0) + p5
         endif else begin
           err = gpuLog2FAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLog2: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Take the base 10 logarithm of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = alog10(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * alog10(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLog10, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLog10: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = alog10(*x.data)
         endif else begin
           err = gpuLog10F(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLog10: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * alog10(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuLog10FAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLog10: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Take the natural logarithm of the argument plus 1.0. There are two forms for
; the arguments to this routine::
;
;   p2 = alog(1.0 + p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * alog(p2 * (1.0 + p3) + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLog1p, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLog1p: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = alog(1.0 + *x.data)
         endif else begin
           err = gpuLog1pF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLog1p: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * alog(1.0 + p2 * *x.data + p4) + p5
         endif else begin
           err = gpuLog1pFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLog1p: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the sine of the argument. There are two forms for the arguments to this
; routine::
;
;   p2 = sin(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * sin(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuSin, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuSin: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = sin(*x.data)
         endif else begin
           err = gpuSinF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuSin: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * sin(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuSinFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuSin: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the cosine of the argument. There are two forms for the arguments to
; this routine::
;
;   p2 = cos(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * cos(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuCos, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuCos: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = cos(*x.data)
         endif else begin
           err = gpuCosF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuCos: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * cos(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuCosFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuCos: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the tangent of the argument. There are two forms for the arguments to
; this routine::
;
;   p2 = tan(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * tan(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuTan, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuTan: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = tan(*x.data)
         endif else begin
           err = gpuTanF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuTan: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * tan(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuTanFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuTan: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the arc sine of the argument. There are two forms for the arguments to
; this routine::
;
;   p2 = asin(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * asin(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuAsin, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuAsin: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = asin(*x.data)
         endif else begin
           err = gpuAsinF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuAsin: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * asin(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuAsinFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuAsin: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the arc cosine of the argument. There are two forms for the arguments
; to this routine::
;
;   p2 = acos(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * acos(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuAcos, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuAcos: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = acos(*x.data)
         endif else begin
           err = gpuAcosF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuAcos: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * acos(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuAcosFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuAcos: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the arc tangent of the argument. There are two forms for the arguments
; to this routine::
;
;   p2 = atan(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * atan(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Bugs:
;    Not sure if I need PHASE keyword
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuAtan, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuAtan: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = atan(*x.data)
         endif else begin
           err = gpuAtanF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuAtan: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * atan(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuAtanFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuAtan: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the error function of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = erf(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * erf(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuErf, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuErf: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = erf(*x.data)
         endif else begin
           err = gpuErfF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuErf: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * erf(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuErfFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuErf: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the natural log of the gamma function of the argument. There are two
; forms for the arguments to this routine::
;
;   p2 = LNGAMMA(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * LNGAMMA(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLgamma, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLgamma: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = lngamma(*x.data)
         endif else begin
           err = gpuLgammaF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLgamma: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * lngamma(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuLgammaFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLgamma: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the gamma function of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = GAMMA(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * GAMMA(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuTgamma, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuTgamma: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = gamma(*x.data)
         endif else begin
           err = gpuTgammaF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuGamma: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * gamma(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuTgammaFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuTgamma: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Take the base r logarithm of the argument, where r is the radix of the
; machine's floating point arithmetic. There are two forms for the arguments
; to this routine::
;
;   p2 = alog(p1) / alog(r)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * alog(p2 * p3 + p4) / alog(r) + 5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLogb, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLogb: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           ma = machar()
           *p2.data = alog(*x.data) / alog(ma.ibeta)
         endif else begin
           err = gpuLogbF(x.n_elements, x.handle, p2.handle)
         endelse
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLogb: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           ma = machar()
           *p6.data = p1 * alog(p2 * *x.data + p4)/alog(ma.ibeta) + p5
         endif else begin
           err = gpuLogbFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLogb: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Truncates (rounds to zero) the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = FLOAT(LONG(p1))
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * FLOAT(LONG(p2 * p3 + p4)) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuTrunc, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuTrunc: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p2.data = fix(long64(*x.data), type=type)
         endif else begin
           err = gpuTruncF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuTrunc: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p6.data = p1 * fix(long64(p2 * *x.data + p4), type=type) + p5
         endif else begin
           err = gpuTruncFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuTrunc: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Rounds the argument. There are two forms for the arguments to this routine::
;
;   p2 = round(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * round(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuRound, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuRound: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = round(*x.data)
         endif else begin
           err = gpuRoundF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuRound: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * round(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuRoundFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuRound: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Rounds the argument. There are two forms for the arguments to this routine::
;
;   p2 = round(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * round(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Bugs:
;    In IDL mode, should round in the "current rounding direction", but this
;    routine just rounds to nearest integer.
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuRint, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuRint: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = round(*x.data)
         endif else begin
           err = gpuRintF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuRint: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * round(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuRintFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuRint: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Rounds the argument. There are two forms for the arguments to this routine::
;
;   p2 = round(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * round(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Bugs:
;    In IDL mode, should round in the "current rounding direction", but this
;    routine just rounds to nearest integer.
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuNearbyint, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuNearbyint: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = round(*x.data)
         endif else begin
           err = gpuNearbyintF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuNearbyint: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * round(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuNearbyintFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuNearbyint: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the ceil of the argument. There are two forms for the arguments
; to this routine::
;
;   p2 = ceil(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * ceil(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuCeil, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuCeil: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = ceil(*x.data)
         endif else begin
           err = gpuCeilF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuCeil: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * ceil(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuCeilFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuCeil: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Takes the floor of the argument. There are two forms for the arguments
; to this routine::
;
;   p2 = floor(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * floor(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuFloor, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuFloor: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = floor(*x.data)
         endif else begin
           err = gpuFloorF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuFloor: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * floor(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuFloorFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuFloor: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Rounds the argument. There are two forms for the arguments to this routine::
;
;   p2 = Lrint(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * Lrint(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Bugs:
;    In IDL mode, should round in the "current rounding direction", but this
;    routine just rounds to nearest integer.

;    This routine returns the same type as the input GPU array instead of
;    a long in order to match the behavoir of gpuLroundF(AT).
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLrint, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLrint: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = round(*x.data)
         endif else begin
           err = gpuLrintF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLrint: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * round(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuLrintFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLrint: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Rounds the argument. There are two forms for the arguments to this routine::
;
;   p2 = round(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * round(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Bugs:
;    This routine returns the same type as the input GPU array instead of
;    a long in order to match the behavoir of gpuLroundF(AT).
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuLround, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuLround: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p2.data = fix(round(*x.data), type=type)
         endif else begin
           err = gpuLroundF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuLround: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * round(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuLroundFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuLround: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Indicates whether the argument is negative. There are two forms for the
; arguments to this routine::
;
;   p2 = p1 lt 0
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * ((p2 * p3 + p4) lt 0) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; Note: unlike the IDL lt operator, this test will indicate that
; -!values.f_infinity is less than zero.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuSignbit, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuSignbit: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin

           type = size(*x.data, /type)
           *p2.data = fix(*x.data lt 0, type=type)

           ; IDL says -!values.f_infinity is not less than zero, so we need
           ; to fix that here
           ind = where(*x.data eq -!values.f_infinity, nNegInf)
           if (nNegInf gt 0) then (*p2.data)[ind] = fix(1, type=type)
         endif else begin
           err = gpuSignbitF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuSignbit: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           expr = p2 * *x.data + p4

           ; IDL says -!values.f_infinity is not less than zero, so we need
           ; to fix that here
           ind = where(expr eq -!values.f_infinity, nNegInf)
           if (nNegInf gt 0) then expr[ind] = fix(1, type=type)

           *p6.data = p1 * expr + p5
         endif else begin
           err = gpuSignbitFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuSignbit: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Indicates the infinite elements of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = abs(p1) eq !values.f_infinity
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * (abs(p2 * p3 + p4) eq !values.f_infinity) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuIsinf, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuIsinf: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p2.data = fix(abs(*x.data) eq !values.f_infinity, type=type)
         endif else begin
           err = gpuIsinfF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuIsinf: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p6.data = p1 * fix((abs(p2 * *x.data + p4) eq !values.f_infinity), type=type) + p5
         endif else begin
           err = gpuIsinfFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuIsinf: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Indicates the elements of the argument which are NaNs. There are two forms
; for the arguments to this routine::
;
;   p2 = gpuIsNaN(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * gpuIsNaN(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; Note: checking for p1 eq !values.f_nan will not work since::
;
;   IDL> print, !values.f_nan eq !values.f_nan
;      0
;
; so the check involves using FINITE (not NaN or infinite) and removing
; the elements that are infinite.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuIsnan, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuIsnan: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p2.data = fix(~finite(*x.data) and ~(abs(*x.data) eq !values.f_infinity), type=type)
         endif else begin
           err = gpuIsnanF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuIsnan: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           subexpr = p2 * *x.data + p4
           *p6.data = p1 * fix((~finite(subexpr) and ~(abs(subexpr) eq !values.f_infinity)), type=type) + p5
         endif else begin
           err = gpuIsnanFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuIsnan: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Indicates the finite elements of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = finite(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * finite(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuIsfinite, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
 on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuIsFinite: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p2.data = fix(finite(*x.data), type=type)
         endif else begin
           err = gpuIsfiniteF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuIsFinite: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           type = size(*x.data, /type)
           *p6.data = p1 * fix(finite(p2 * *x.data + p4), type=type) + p5
         endif else begin
           err = gpuIsfiniteFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuIsfinite: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;+
; Calculates the absolute value of the argument. There are two forms for the
; arguments to this routine::
;
;   p2 = abs(p1)
;
; where p1 is { GPUHANDLE } or float and p2 is { GPUHANDLE }. Or::
;
;   p6 = p1 * abs(p2 * p3 + p4) + p5
;
; where p2 is { GPUHANDLE } or float and p6 is { GPUHANDLE } and
; p1, p2, p4, and p5 are scalar floats.
;
; :Params:
;    p1 : in, required, type=float or { GPUHANDLE }
;    p2 : in, out, required, type=float or { GPUHANDLE }
;    p3 : in, optional, type={ GPUHANDLE }
;    p4 : in, optional, type=float
;    p5 : in, optional, type=float
;    p6 : out, optional, type={ GPUHANDLE }
;
; :Keywords:
;    NONBLOCKING : in, optional, type=boolean
;       unless this keyword is set, this will block until the device has
;       completed all preceding requested tasks
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuFabs, p1, p2, p3, p4, p5, p6, NONBLOCKING=nonblocking, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    2: begin
         if size(p1, /type) ne 8 then gpuPutArr, p1, x else x = p1
         if size(p2, /type) ne 8 then p2 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p2.n_elements then begin
           if size(p1, /type) ne 8 then gpuFree, x
           if size(p2, /type) ne 8 then gpuFree, p2
           message, level=-1, 'gpuFabs: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p2.data = abs(*x.data)
         endif else begin
           err = gpuFabsF(x.n_elements, x.handle, p2.handle)
         endelse

         if size(p1, /type) ne 8 then gpuFree, x
       end
    6: begin
         if size(p3, /type) ne 8 then gpuPutArr, p3, x else x = p3
         if size(p6, /type) ne 8 then p6 = gpuFltarr(x.n_elements, /NOZERO)

         if x.n_elements ne p6.n_elements then begin
           if size(p3, /type) ne 8 then gpuFree, x
           if size(p6, /type) ne 8 then gpuFree, p6
           message, level=-1, 'gpuFabs: output vector length missmatch'
         endif

         if (!gpu.mode eq 0) then begin
           *p6.data = p1 * abs(p2 * *x.data + p4) + p5
         endif else begin
           err = gpuFabsFAT(p3.n_elements, float(p1), float(p2), $
                            p3.handle, float(p4), float(p5), p6.handle)
         endelse
         if size(p3, /type) ne 8 then gpuFree, x
       end
    else: message, level=-1, 'gpuFabs: incorrect number of arguments'
  endcase

  if (~keyword_set(NONBLOCKING) && !gpu.mode ne 0) then err OR= cudaThreadSynchronize()
end


;
; IDL specific rouines
;

;+
; Calculates the linear or bilinear interpolates of the given input p_gpu,
; depending on the number of arguments presented. If three arguments are
; given::
;
;    arg3_gpu = interpolate(p_gpu, x_gpu)
;
; If four arguments are given::
;
;    arg4_gpu = interpolate(p_gpu, x_gpu, arg3_gpu)
;
; :Params:
;    p_gpu : in, required, type={ GPUHANDLE }
;       the input array (1D or 2D)
;    x_gpu : in, required, type={ GPUHANDLE }
;       x-values for either form of interpolation
;    arg3_gpu : in, out, required, type={ GPUHANDLE }
;       the return value for linear interpolation or the y-values for
;       bilinear interpolation
;    arg4_gpu : in, optional, type={ GPUHANDLE }
;       the return value for bilinear interpolation
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuInterpolate, p_gpu, x_gpu, arg3_gpu, arg4_gpu, ERROR=err
  on_error, 2

  err = 0

  case n_params() of
    3: begin
         if x_gpu.n_elements ne arg3_gpu.n_elements then begin
           message, level=-1, 'gpuInterpolate: output vector size missmatch'
         end

         if (!gpu.mode eq 0) then begin
           *arg3_gpu.data = interpolate(*p_gpu.data, *x_gpu.data)
         endif else begin
           err = gpuInterpolate1DF(p_gpu.n_elements, p_gpu.handle,  $
                                   x_gpu.n_elements, x_gpu.handle,  $
                                   arg3_gpu.handle)
         endelse
       end
    4: begin
         if p_gpu.n_dimensions ne 2 then begin
           message, level=-1, 'gpuInterpolate: input has to be 2D field'
         end

         if x_gpu.n_elements ne arg3_gpu.n_elements then begin
           message, level=-1, 'gpuInterpolate: input vector size missmatch'
         end

         if x_gpu.n_elements ne arg4_gpu.n_elements then begin
           message, level=-1, 'gpuInterpolate: output vector size missmatch'
         end

         if (!gpu.mode eq 0) then begin
           *arg4_gpu.data = interpolate(*p_gpu.data, *x_gpu.data, *arg3_gpu.data)
         endif else begin
           err = gpuInterpolate2DF(p_gpu.dimensions[0], p_gpu.dimensions[1], $
                                   p_gpu.handle,  x_gpu.n_elements, $
                                   x_gpu.handle,  arg3_gpu.handle, arg4_gpu.handle)
         endelse
      end
  endcase
end


;+
; Calculates the total of the elements of the GPU vector.
;
; :Returns: float
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array to total
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuTotal, x_gpu, ERROR=err

  err = 0
  res = 0.0

  if (!gpu.mode eq 0) then begin
    res = total(*x_gpu.data)
  endif else begin
    err = gpuTotalF(x_gpu.n_elements, x_gpu.handle, res)
  endelse

  return, res
end

;+
; Calculates the maximum of the elements of the GPU vector.
;
; :Returns: float
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array to search for maximum
;    max_subscript : in, optional, type = long
;       position of the first ocurrence of the maximum element
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuMax, x_gpu, max_subscript, ERROR=err

  err = 0
  res = 0.0

  if (!gpu.mode eq 0) then begin
    res = Max(*x_gpu.data, max_subscript)
  endif else begin
    max_subscript = 0L
    err = gpuMaxF(x_gpu.n_elements, x_gpu.handle, res, max_subscript)
  endelse

  return, res
end

;+
; Calculates the minimum of the elements of the GPU vector.
;
; :Returns: float
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array to search for minimum
;    min_subscript : in, optional, type=long
;       position of the first ocurrence of the minimum element
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
function gpuMin, x_gpu, min_subscript, ERROR=err

  err = 0
  res = 0.0

  if (!gpu.mode eq 0) then begin
    res = Min(*x_gpu.data, min_subscript)
  endif else begin
    min_subscript = 0L
    err = gpuMinF(x_gpu.n_elements, x_gpu.handle, res, min_subscript)
  endelse

  return, res
end


;+
; Copies a GPU vector
;
; :Params:
;    x_gpu : in, required, type=float or { GPUHANDLE }
;       GPU array to copy. If and IDL array is provided, it is first
;       copied to the GPU.
;    res_gpu : in, optional, type = any
;       resulting GPU vector. If res_gpu is a {GPUHANDLE} it is used
;       for holding the result, otherwise a new GPU array is created.
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuCopy, x_gpu, res_gpu, ERROR=err
  on_error, 2

  if size(x_gpu, /type) ne 8 then gpuPutArr, x_gpu, x else x = x_gpu
  if size(res_gpu, /type) ne 8 then begin 
     res_gpu = gpuFltarr(x.n_elements, /NOZERO)
     res_gpu.dimensions = x_gpu.dimensions
     res_gpu.n_dimensions = x_gpu.n_dimensions
     new_alloc = 1
  end

  if x.n_elements ne res_gpu.n_elements then begin
     if size(x_gpu, /type) ne 8 then gpuFree, x
     if n_elements(new_alloc) ne 0 then gpuFree, res_gpu 
     message, level=-1, 'gpuCopy: vector length missmatch'
  endif

  if (!gpu.mode eq 0) then begin
    (*res_gpu.data)  = (*x.data)
  endif else begin
    err = cudaMemcpy(res_gpu.handle, x.handle, x.n_elements * 4L, 3L)
  endelse

  if size(x_gpu, /type) ne 8 then gpuFree, x
end




;+
; Change the dimensions of a GPU variable without changing the total number of
; elements.
;
; Warning: this routine modifies the input GPU variable whereas the REFORM
; function does not unless the OVERWRITE keyword is set.
;
; :Params:
;    arr_gpu : in, out, required, type={ GPUHANDLE }
;       GPU variable to manipulate
;    xsize : in, optional, type=long
;       new xsize of arr_gpu
;    ysize : in, optional, type=long
;       new ysize of arr_gpu
;-
pro gpuReform, arr_gpu, xsize, ysize
  on_error, 2

  case n_params() of
    1: begin
         ; remove unneeded leading dimensions just like REFORM
         if (arr_gpu.n_dimensions eq 2L && arr_gpu.dimensions[0] eq 1L) then begin
           arr_gpu.n_dimensions = 1L
           arr_gpu.dimensions = [arr_gpu.dimensions[1], 0L]
         endif

         ; if IDL mode then REFORM the actuall data too
         if (!gpu.mode eq 0) then begin
           *arr_gpu.data = reform(*arr_gpu.data, /overwrite)
         endif
       end
    2: begin
         ; check to make sure the reform keeps the same number of elements
         if (xsize ne arr_gpu.n_elements) then begin
           message, level = -1, 'gpuReform: attempt to change number of elements'
         endif

         ; change n_dimensions to 1
         arr_gpu.n_dimensions = 1L

         ; change dimensions to xsize
         arr_gpu.dimensions = [xsize, 0L]

         ; if IDL mode then REFORM the actuall data too
         if (!gpu.mode eq 0) then begin
           *arr_gpu.data = reform(*arr_gpu.data, xsize, /overwrite)
         endif
       end
    3: begin
         ; check to make sure the reform keeps the same number of elements
         if (xsize * ysize ne arr_gpu.n_elements) then begin
           message, level = -1, 'gpuReform: attempt to change number of elements'
         endif

         arr_gpu.n_dimensions = 2L
         arr_gpu.dimensions = [xsize, ysize]

         ; if IDL mode then REFORM the actuall data too
         if (!gpu.mode eq 0) then begin
           *arr_gpu.data = reform(*arr_gpu.data, xsize, ysize, /overwrite)
         endif
       end
  endcase
end


;+
; Changes the resolution of an array, either using interpolation
; or nearest grid point sampling.
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array to change resolution of. Currently only supports 2D
;    nx    : in, required, type=long
;       X resolution of resulting image
;    ny    : in, required, type=long
;       Y resolution of resulting image
;    res_gpu : out, required, type={ GPUHANDLE }
;       resulting array.
;
; :Keywords:
;    INTERP : in, optional, type=integer
;       if set, use bilinear interpolation. Otherwise use nearest grid point.
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuCongrid, x_gpu, nx, ny, res_gpu, INTERP=interp, ERROR=err
  on_error, 2

  err = 0

  ; res_gpu has zero size
  if size(res_gpu.n_elements, /type) eq 0 then begin
    res_gpu = gpuFltarr(nx, ny, /NOZERO)
    res_gpu.n_dimensions = x_gpu.n_dimensions
    res_gpu.dimensions   = x_gpu.dimensions
  endif

  if (nx * ny ne res_gpu.n_elements) then begin
    gpuFree, res_gpu
    res_gpu = gpuFltarr(nx, ny, /NOZERO)
  endif

  if (!gpu.mode eq 0) then begin
    *res_gpu.data = congrid(*x_gpu.data, nx, ny, interp=keyword_set(interp))
  endif else begin
    err = gpuCongrid2DF($
             x_gpu.dimensions[0], x_gpu.dimensions[1], x_gpu.handle,       $
             res_gpu.dimensions[0], res_gpu.dimensions[1], res_gpu.handle, $
             keyword_set(interp))
  endelse

end

;+
;
; Places a view onto a GPU object
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       array to create a view on
;    px    : in, required, type = {int}
;       array element of origin of view
;    nx    : in, required, type = { int}
;       number of elements in view
;     res_gpu : out, required, type = { GPUHANDLE }
;       gpu variable of view onto x_gpu
;-
pro gpuView, x_gpu, px, nx, res_gpu
 
  res_gpu = x_gpu
  res_gpu.n_elements = nx
  res_gpu.dimensions = [nx, 1]
  if (!gpu.mode eq 0)  then begin
   message, level=-1, 'gpuView: not available in emulation'
  end else begin
   res_gpu.handle = res_gpu.handle + px * 4
  end
end 

;+
;
; Extract a subset of an array and store it in a subset of the result array.
;
; :Params:
;    p1 : in, required, type={ GPUHANDLE }
;       src_gpu: GPU array to extract subarray from.
;    p2 : in, required, type=int or intarr
;       src_x: index[array] of src_gpu x dimension. When src_x is an int, this is the
;       x-index to be extracted. When src_x is a 2-element int-arr, this is array is
;       of the form [lower, upper] and lower and upper index of the x-subrange.
;       src_x, lower or upper can be -1, specifying a the full range (equivalent
;       to IDL's '*'.
;    p3 : in, type=int or intarr
;       src_y: index[array] of src_gpu y dimension. For more details see src_x;
;       required if x_gpu is 2D
;    p4 : in, required, type = { GPUHANDLE }
;       dest_gpu: GPU array to store subarray into
;    p5 : in, required, type=int or intarr
;       dest_x: index[array] of dest_gpu x dimension. For more details see src_x.
;    p6 : in, type=int or intarr
;       dest_y: index[array] of dest_gpu y dimension. For more details see
;       src_x; required if dest is 2D
;
;-
pro gpuSubArr, p1, p2, p3, p4, p5, p6
 on_error, 2

 src = p1

 ; clean up input arguments
 if src.n_dimensions eq 1 then begin ; 2nd parameter is range
     sxrange = long(p2)
     syrange = 0L
     dest = p3
     dxrange = long(p4)
     dyrange = (dest.n_dimensions eq 2) ? long(p5) : 0L
 end else begin                 ; we have a 2d object
     sxrange = long(p2)
     syrange = long(p3)
     dest = p4
     dxrange = long(p5)
     dyrange = (dest.n_dimensions eq 2) ? long(p6) : 0L
 end


;-- source range

; compute offset
 sxoff = sxrange[0]
 if sxrange[0] eq -1 then sxoff = 0L

 syoff = syrange[0]
 if syrange[0] eq -1 then syoff = 0L

 soff = sxoff  + syoff * src.dimensions[0]

; compute width
 if n_elements(sxrange) eq 1 then begin
     swidth = (sxrange[0] eq -1) ? src.dimensions[0] : 1L
 end else begin
     top = (sxrange[1] eq -1) ? src.dimensions[0] : sxrange[1]+1
     swidth = (top - sxrange[0])
 end

; compute height
 if n_elements(syrange) eq 1 then begin
     sheight = (syrange[0] eq -1) ? src.dimensions[1] : 1L
 end else begin
     top = (syrange[1] eq -1)? src.dimensions[1] : syrange[1]+1
     sheight = (top - syrange[0])
 end


;-- destination range

; compute offset
 dxoff = dxrange[0]
 if dxrange[0] eq -1 then dxoff = 0L

 dyoff = dyrange[0]
 if dyrange[0] eq -1 then dyoff = 0L

 doff = dxoff + dyoff * dest.dimensions[0]

; compute width
 if n_elements(dxrange) eq 1 then begin
     dwidth = (dxrange[0] eq -1) ? dest.dimensions[0] : 1L
 end else begin
     top = (dxrange[1] eq -1) ? dest.dimensions[0] : dxrange[1]+1
     dwidth = (top - dxrange[0])
 end

; compute height
 if n_elements(dyrange) eq 1 then begin
     dheight = (dyrange[0] eq -1) ? dest.dimensions[1] : 1L
 end else begin
     top = (dyrange[1] eq -1) ? dest.dimensions[1] : dyrange[1]+1L
     dheight = (top - dyrange[0])
 end

; different cases for copying:
; 1D src, 1D dest
; 1D src, 2D dest
; 2D src, 1D dest
; 2D src, 2D dest


; 1D src, 1D dest
 if (sheight eq 1) and (dheight eq 1) then begin
     if swidth ne dwidth then begin
         message, level=-1, 'gpuSubArr: invalid vector sizes'
     end

	 if (!gpu.mode eq 0) then begin
          (*dest.data)[doff:doff+swidth-1] = (*src.data)[soff:soff+swidth-1]
     end else begin
          err = cudaMemcpy(dest.handle+4L*doff, src.handle+4L*soff, swidth*4L, 3L)
     end
     return
 end

; 1D src, 2D dest
 if (sheight eq 1) and (dwidth eq 1) then begin
     if swidth ne dheight then begin
         message, level=-1, 'gpuSubArr: invalid vector sizes'
     end

	 if (!gpu.mode eq 0) then begin
          (*dest.data)[dxoff, dyoff:dyoff+dheight-1] = (*src.data)[soff:soff+dheight-1]
     end else begin
          err = cudaMemcpy2D(dest.handle+4L*doff, dest.dimensions[0]*4L, $
                        src.handle+4L*soff, 4L, 4L, dheight, 3L)
     end
     return
 end

; 2D src, 1D dest
 if (swidth eq 1) and (dheight eq 1) then begin
     if sheight ne dwidth then begin
         message, level=-1, 'gpuSubArr: invalid vector size'
     end
     if (!gpu.mode eq 0) then begin
          (*dest.data)[doff:doff+sheight-1] = (*src.data)[sxoff, syoff:syoff+sheight-1]
     end else begin
          err = cudaMemcpy2D(dest.handle+4L*doff, 4L, $
                       src.handle+4L*soff, src.dimensions[0]*4L, $
                       4L, sheight, 3L)
     end
     return
 end

; 2D src, 2D dest
 if swidth * sheight ne dwidth * dheight then begin
     message, level=1, 'gpuSubArr: invalid number of elements'
 end

; no gap means no break in x direction. If height eq 1 then anything,
; if height ne 1, then width has to be dimension[0]*4L

 snogap = (sheight eq 1) or (swidth eq src.dimensions[0])
 dnogap = (dheight eq 1) or (dwidth eq dest.dimensions[0])
 
; both source and destionation are contiguous blocks
 if snogap and dnogap then begin

   if (!gpu.mode eq 0) then begin
       (*dest.data)[doff:doff+swidth*sheight-1] = $
                  (*src.data)[soff:soff+swidth*sheight-1]
   end else begin
        err = cudaMemcpy(dest.handle+4L*doff, src.handle+4L*soff, $
                  swidth*sheight*4L, 3L)
   end
   return
 end

; src is contiguous block, dest has gaps
 if snogap and ~dnogap then begin
   if (!gpu.mode eq 0) then begin
       (*dest.data)[dxoff:dxoff+dwidth-1, dyoff:dyoff+dheight-1] =    $
             (*src.data)[soff:soff+dwidth*dheight-1]
   end else begin
       err = cudaMemcpy2D(dest.handle+4L*doff, dest.dimensions[0]*4L, $
                     src.handle+4L*soff, 4L*dwidth,                $
                     4L*dwidth, dheight, 3L)
   end
   return
 end

 ; src has gap, dest is contiguous
 if ~snogap and dnogap then begin
  if (!gpu.mode eq 0) then begin
       (*dest.data)[doff:doff+swidth*sheight-1] = $
                (*src.data)[sxoff:sxoff+swidth-1, syoff:syoff+sheight-1]
  end else begin
       err = cudaMemcpy2D(dest.handle+4L*doff, 4L*swidth, $
                     src.handle+4L*soff, src.dimensions[0] * 4L ,$
                     4L*swidth, sheight, 3L)
  end
  return
 end

 if (!gpu.mode eq 0) then begin
       (*dest.data)[dxoff+dxoff+dwidth-1, dyoff:dyoff+dheight-1] = $
               (*src.data)[sxoff:sxoff+swidth-1, syoff:syoff+sheight-1]
 end else begin
    err = cudaMemcpy2D(dest.handle+4L*doff, dest.dimensions[0]*4L, $
                    src.handle+4L*soff, src.dimensions[0]*4L, $
                    4L*swidth, sheight, 3L)
 end
end


;+
; Subscripts a GPU array with another GPU array
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array representing the indices
;    y_gpu : in, required, type={ GPUHANDLE }
;       GPU array representing the array to be subscripted
;    res_gpu : out, required, type={ GPUHANDLE }
;       GPU array conaining values of y_gpu subscripted by x_gpu
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuSubscript, x_gpu, y_gpu, res_gpu, ERROR=err
 on_error, 2

 if size(x_gpu, /type) ne 8 then gpuPutArr, x_gpu, x else x = x_gpu
 if size(y_gpu, /type) ne 8 then gpuPutArr, y_gpu, y else y = y_gpu
 if size(res_gpu, /type) ne 8 then begin
   res_gpu = gpuFltarr(x.n_elements, /NOZERO)
   new_alloc = 1
 end

 if x.n_elements ne res_gpu.n_elements then begin
    if size(x_gpu, /type) ne 8 then gpuFree, x
    if size(y_gpu, /type) ne 8 then gpuFree, y
    if n_elements(new_alloc) ne 0 then gpuFree, res_gpu
    message, level=-1, 'gpuSubscript: vector length missmatch'
 endif
 
 if (!gpu.mode eq 0) then begin
   *res_gpu.data = (*y.data)[(*x.data)]
 end else begin
   err = gpuSubscriptF(x.n_elements, $
                    x.handle, y.handle, res_gpu.handle)
 end

 if size(x_gpu, /type) ne 8 then gpuFree, x
 if size(y_gpu, /type) ne 8 then gpuFree, y
end


;+
; Computes the prefix sum on a GPU array
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array to be summed
;    res_gpu : out, required, type={ GPUHANDLE }
;       GPU array conaining the result
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuPrefixSum, x_gpu, res_gpu, ERROR=err
 on_error, 2

 if size(x_gpu, /type) ne 8 then gpuPutArr, x_gpu, x else x = x_gpu
 if size(res_gpu, /type) ne 8 then begin
   res_gpu = gpuFltarr(x.n_elements, /NOZERO)
   new_alloc = 1
 end

 if x.n_elements ne res_gpu.n_elements then begin
    if size(x_gpu, /type) ne 8 then gpuFree, x
    if n_elements(new_alloc) ne 0 then gpuFree, res_gpu
    message, level=-1, 'gpuPrefixSum: vector length missmatch'
 endif

 if (!gpu.mode eq 0) then begin
   *res_gpu.data = total( *x.data, /cumulative)
 end else begin
   err = gpuPrefixSumF(x.n_elements, x.handle, res_gpu.handle)
 end

 if size(x_gpu, /type) ne 8 then gpuFree, x
end


;+
; Scans the (float-boolean) input vector and stores the indices of
; the true elements in the output vector. The input vector is
; overwritten.
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array containing the flags
;    res_gpu : out, required, type={ GPUHANDLE }
;       GPU array icontaining the indices of the true elements
;       in the input vector.
;    count : out, optional, type=long
;       number of true elements
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuWhere, x_gpu, res_gpu, count, ERROR=err
 on_error, 2

 count = [0.]

 if (!gpu.mode eq 0) then begin
   r =  where(*x_gpu.data, count)
   res_gpu = gpuFltarr(count, /nozero)
   res_gpu.data = ptr_new(r)
   return
 end 

; get the last element of the flag vector
 lastElement = x_gpu
 lastElement.handle = lastElement.handle +  4 * (lastElement.n_elements - 1)
 lastElement.n_elements = 1
 lastElement.n_dimensions = 1 
 lastElement.dimensions = [1, 0]
 lastX = fltarr(1)
 gpuGetArr, lastElement, lastX

 err = gpuPrefixSumF(x_gpu.n_elements, x_gpu.handle, x_gpu.handle)

; determine the size of the resulting array 
 gpuGetArr, lastElement, count 
 
 if lastX[0] ne 0 then count = count + 1

 if count eq 0 then begin
   res_gpu = gpuGetHandle()
   return
 end

; if result vector is already allocated, free it first
 if size(res_gpu, /type) eq 8 then gpuFree, res_gpu

; allocate space for the result vector
 res_gpu = gpuFltarr(count, /NOZERO)

; copy elements to result vector
 err = gpuWhereF(x_gpu.n_elements, x_gpu.handle, res_gpu.handle, lastX[0])

end



;+
; This routine generates uniformly distributed random numbers on the GPU
;
;; :Params:
;    seed: in, required, type=int
;       seed for RNG. Can be undeined
;    nx : in, required, type=int
;       x-dimension of resulting random array
;    ny : out, optional, type=int
;       y-dimension of resulting random array
;    x_gpu : in, required, type={ GPUHANLE }
;       variable to store random numbers in
;
; :Keywords:
;    NORMAL: in, optional, type=bool
;       generate a normal distribution, rather than a uniform one
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuRandomu, seed, nx, ny, x_gpu, ERROR=err, NORMAL=normal 

  if n_elements(seed) ne 0 then  err = gpuSeedMTF(long(seed))

  case n_params() of
    3 : begin
          ; in this case, ny contains the result
          if size(ny, /type) ne 8 then ny = gpuFltarr(nx, /NOZERO)
          if ny.n_elements ne nx then begin
            message, level=-1, 'gpuRandomu: vector length missmatch'
          end
          err = gpuMTF(long(nx), ny.handle)
          if keyword_set(NORMAL) then $
               err = gpuBoxMullerF(long(nx), ny.handle)
        end
    4 : begin
          nxy = long(nx) * long(ny)
          if size(x_gpu, /type) ne 8 then x_gpu = gpuFltarr(nxy, /NOZERO)
          if x_gpu.n_elements ne nxy then begin
            message, level=-1, 'gpuRandomu: vector length missmatch'
          end
          err = gpuMTF(nxy, x_gpu.handle)
          if keyword_set(NORMAL) then $
               err = gpuBoxMullerF(long(nx),x_gpu.handle)
        end
    else: begin
          message, level=-1, 'gpuRandomu: Invalid number of arguments'
        end
 
  endcase

end

;+
; This routine generates normally distributed random numbers on the GPU
;
;; :Params:
;    seed: in, required, type=int
;       seed for RNG. Can be undeined
;    nx : in, required, type=int
;       x-dimension of resulting random array
;    ny : out, optional, type=int
;       y-dimension of resulting random array
;    x_gpu : in, required, type={ GPUHANLE }
;       variable to store random numbers in
;
; :Keywords:
;    UNIFORM: in, optional, type=bool
;       generate a normal distribution, rather than a uniform one
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuRandomn, seed, nx, ny, x_gpu, ERROR=err
  gpuRandomu, seed, nx, ny, x_gpu, ERROR=err, /NORMAL
end 


;---- linear algebra routines
;+
; Performs multiplication of two gpu matrices or their
; transposes.
;
; :Params:
;    a_gpu : in, required, type={ GPUHANDLE }
;       GPU array containing the matrix A
;    b_gpu : in, required, type={ GPUHANDLE }
;       GPU array containing the matrix B
;    res_gpu : out, required, type={ GPUHANDLE }
;       GPU array containing the product
;
; :Keywords:
;    ATRANSPOSE : in, optional, type=bool
;       use A transpose of A for product
;    BTRANSPOSE : in, optional, type=bool
;       use B transpose of B for product
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuMatrix_Multiply, a_gpu, b_gpu, res_gpu, $
      ATRANSPOSE=atranspose, BTRANSPOSE=btranspose, ERROR=err
  on_error, 2
  
  if size(a_gpu, /type) ne 8 then gpuPutArr, a_gpu, a else a = a_gpu
  if size(b_gpu, /type) ne 8 then gpuPutArr, b_gpu, b else b = b_gpu

  if a.dimensions[1] eq 0 then a.dimensions[1] = 1
  if b.dimensions[1] eq 0 then b.dimensions[1] = 1

  if size(res_gpu, /type) ne 8 then begin
     cx = keyword_set(ATRANSPOSE) ? a.dimensions[1] : a.dimensions[0]
     cy = keyword_set(BTRANSPOSE) ? b.dimensions[0] : b.dimensions[1]
     res_gpu = gpuFltarr(cx, cy, /NOZERO)
     new_alloc = 1
  end
   
  if (~keyword_set(ATRANSPOSE) and $
       res_gpu.dimensions[0] ne a.dimensions[0]) $
   or (keyword_set(ATRANSPOSE) and $
       res_gpu.dimensions[0] ne a.dimensions[1]) then begin
;    print, a.dimensions
;    print, b.dimensions
;    print, res_gpu.dimensions
    if size(a_gpu, /type) ne 8 then gpuFree, a
    if size(b_gpu, /type) ne 8 then gpuFree, b
    message, level=-1, 'gpuMatrix_Multiply: Error in dimension A'
  end

  if (~keyword_set(BTRANSPOSE) and $
       res_gpu.dimensions[1] ne b.dimensions[1]) $
   or (keyword_set(BTRANSPOSE) and $
       res_gpu.dimensions[1] ne b.dimensions[0]) then begin
    print, a.dimensions
    print, b.dimensions
    print, res_gpu.dimensions
    if size(a_gpu, /type) ne 8 then gpuFree, a
    if size(b_gpu, /type) ne 8 then gpuFree, b
    message, level=-1, 'gpuMatrix_Multiply: Error in dimension B'
  end

  m = keyword_set(ATRANSPOSE) ? a.dimensions[1] : a.dimensions[0]
  n = keyword_set(BTRANSPOSE) ? b.dimensions[0] : b.dimensions[1]
  k = keyword_set(ATRANSPOSE) ? a.dimensions[0] : a.dimensions[1]
 
;  print, 'm = ', m, '  n = ', n, ' k = ', k

  if (keyword_set(BTRANSPOSE) and k ne b.dimensions[1]) or $
     (~keyword_set(BTRANSPOSE) and k ne b.dimensions[0]) then begin
    if size(a_gpu, /type) ne 8 then gpuFree, a
    if size(b_gpu, /type) ne 8 then gpuFree, b
    message, level=-1, 'gpuMatrix_Multiply: Matrix size mismatch' 
  endif
   
  if (!gpu.mode eq 0) then begin 
   *res_gpu.data = matrix_multiply(*a.data, *b.data, $
             ATRANSPOSE=atranspose, BTRANSPOSE=btranspose)
  end else begin
    at = keyword_set(ATRANSPOSE) ? 'T' : 'N'
    bt = keyword_set(BTRANSPOSE) ? 'T' : 'N'

    
    err =  cublasSgemm(at, bt, long(m), long(n), long(k), $
            float(1), a.handle, long(a.dimensions[0]), $
                      b.handle, long(b.dimensions[0]), $
            float(0), res_gpu.handle, long(res_gpu.dimensions[0])) 
  end

  if size(a_gpu, /type) ne 8 then gpuFree, a
  if size(a_gpu, /type) ne 8 then gpuFree, b
end

;---- fft and related functions

;+
; Extracts the real part of a complex data object on the GPU
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array representing a complex array
;    res_gpu : out, required, type={ GPUHANDLE }
;       GPU array conaining the real part of the input
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuReal, x_gpu, res_gpu, ERROR=err
 on_error, 2

 if size(x_gpu, /type) ne 8 then gpuPutArr, x_gpu, x else x = x_gpu
 if size(res_gpu, /type) ne 8 then begin
    res_gpu = gpuFltarr(x.n_elements/2, /NOZERO)
    new_alloc  = 1
 end

 if x.n_elements ne 2*res_gpu.n_elements then begin
    if size(x_gpu, /type) ne 8 then gpuFree, x
    if n_elements(new_alloc) ne 0 then gpuFree, res_gpu
    message, level=-1, 'gpuReal: vector length missmatch'
 endif

 if (!gpu.mode eq 0) then begin
   *res_gpu.data = (*x.data)[0:*:2]
 end else begin
   err = cudaMemCpy2D(res_gpu.handle, 4L, $       ; result has stride 4 bytes
                      x.handle, 2*4L,     $       ; source has stride 8 bytes
                      4L, res_gpu.n_elements, $   ; copy a window 4 x n_elements
                      3L)                         ; GPU ->GPU transfer
 end

 if size(x_gpu, /type) ne 8 then gpuFree, x
end

;+
; Extracts the imaginary part of a complex data object on the GPU
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array representing a complex array
;    res_gpu : out, required, type={ GPUHANDLE }
;       GPU array conaining the imaginary part of the input
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuImaginary, x_gpu, res_gpu, ERROR=err
 on_error, 2

 if size(x_gpu, /type) ne 8 then gpuPutArr, x_gpu, x else x = x_gpu
 if size(res_gpu, /type) ne 8 then begin
    res_gpu = gpuFltarr(x.n_elements/2, /NOZERO)
    new_alloc  = 1
 end

 if x.n_elements ne 2*res_gpu.n_elements then begin
    if size(x_gpu, /type) ne 8 then gpuFree, x
    if n_elements(new_alloc) ne 0 then gpuFree, res_gpu
    message, level=-1, 'gpuImaginary: output vector length missmatch'
 endif

 if (!gpu.mode eq 0) then begin
   *res_gpu.data = (*x.data)[0:*:2]
 end else begin
   err = cudaMemCpy2D(res_gpu.handle, 4L,     $   ; result has stride 4 bytes
                      x.handle+4L, 2*4L,      $   ; source has stride 8 bytes
                      4L, res_gpu.n_elements, $   ; copy a window 4 x n_elements
                      3L)                         ; GPU ->GPU transfer
 end

 if size(x_gpu, /type) ne 8 then gpuFree, x
end


;+
; Combines two GPU arrays, re_gpu and im_gpu into a single, complex GPU array
; res_gpu.
;
; :Params:
;    re_gpu : in, required, type={ GPUHANDLE }
;       GPU array representing the real part of the result
;    im_gpu : in, required, type={ GPUHANDLE }
;       GPU array representing the imaginary part of the result
;    res_gpu : out, required, type={ GPUHANDLE }
;       complex GPU array
;
; :Keywords:
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuComplex, re_gpu, im_gpu, res_gpu, ERROR=err
 on_error, 2

 if size(re_gpu, /type) ne 8 then gpuPutArr, re_gpu, re else re = re_gpu
 if size(im_gpu, /type) ne 8 then gpuPutArr, im_gpu, im else im = im_gpu

 if re.n_elements ne im.n_elements then begin
    if size(re_gpu, /type) ne 8 then gpuFree, re 
    if size(im_gpu, /type) ne 8 then gpuFree, im 
    message, level=-1, 'gpuComplex: input vector length missmatch'
 end

 if size(res_gpu, /type) ne 8 then begin
   res_gpu = gpuFltarr(2*re.n_elements, /NOZERO)
   alloc_new = 1
 end

 if re.n_elements*2 ne res_gpu.n_elements then begin
    if size(re_gpu, /type) ne 8 then gpuFree, re 
    if size(im_gpu, /type) ne 8 then gpuFree, im 
    if n_elements(alloc_new) ne 0 then gpuFree, res_gpu
    message, level=-1, 'gpuComplex: output vector length missmatch'
 endif

 if (!gpu.mode eq 0) then begin
   (*res_gpu.data)[0:*:2] = *re.data
   (*res_gpu.data)[1:*:2] = *im.data
 end else begin
   err = cudaMemCpy2D(res_gpu.handle, 2*4L,  $   ; result has stride 8 bytes
                      re.handle, 4L,         $   ; source has stride 8 bytes
                      4L, re.n_elements,     $   ; copy a window 4 x n_elements
                      3L)                        ; GPU ->GPU transfer

   err = cudaMemCpy2D(res_gpu.handle+4L, 2*4L,$  ; result has stride 8 bytes
                      im.handle, 4L,          $  ; source has stride 8 bytes
                      4L, im.n_elements,      $  ; copy a window 4 x n_elements
                      3L)                        ; GPU ->GPU transfer
 end

 if size(re_gpu, /type) ne 8 then gpuFree, re
 if size(im_gpu, /type) ne 8 then gpuFree, im
end


;+
; Perform FFT on the GPU
;
; The FFT can operate either on real or complex signals, and perform
; both 1D and 2D transforms. Complex number arrays use an interleaved
; memory layout and are otherwise treated as regular real arrays. Use
; the gpuReal and gpuImaginary routines to extract the real and imaginary
; component.
;
; :Params:
;    x_gpu : in, required, type={ GPUHANDLE }
;       GPU array to perform FFT on
;    res_gpu: out, required, type={ GPUHANDLE }
;       GPU array containing the result
;
; :Keywords:
;    PLAN: in, out, optional, type=long
;       The plan to be used for this transform. If undefined upon
;       entry, a new plan will be created and returned in this variable.
;    REAL2COMPLEX: in, optional, type=boolean
;       Perform a real to complex fft. This transform is implicitly
;       forward.
;    COMPLEX2REAL: in, optional, type=boolean
;       Performa a complex to real fft. This transform is implicitly
;       inverse.
;    COMPLEX2COMPLEX: in, optional, type=boolean
;       Perform a complex to complex fft. By default, this transform is
;       forward, but using can be reversed by using the INVERSE keyword
;    INVERSE: in, optional, type=boolean
;       Perform an inverse complex to complex fft. Only valid in combination
;       with the COMPLEX2COMPLEX keyword.
;    DIM2D: in, optional, type=boolean
;       Perform a 2D fft on the input data set. The dimensionality is
;       extracted from the input object.
;    DENORMALIZED: in, optional, type=boolean
;       Perform a denormalized transform. By default, the result is
;       normalized by the number of input vector elements. This option
;       allows to skip this normalization step, yielding slightly faster
;       exectution.
;    DESTROYPLAN: in, optional, type=boolen
;       Frees the GPU resoures occupied by the fft plan. This invalidates
;       the plan and requires a new plan to be generated.
;    ERROR: out, optoinal, type=int
;       Error code.
;
;-
pro gpufft, x_gpu, res_gpu, PLAN=plan, REAL2COMPLEX=real2complex, $
   COMPLEX2REAL=complex2real, COMPLEX2COMPLEX=complex2complex, $
   INVERSE=inverse, DIM2D=DIM2D, DENORMALIZED=denormalized, $
   DESTROYPLAN=destroyplan, BATCH=batch, ERROR=err

 on_error, 2

 if (keyword_SET(real2complex)+keyword_set(complex2real)+$
     keyword_set(complex2complex)) gt 1 then begin
     message, level=-1, 'gpuFFT: Only one transfer type can be specified'
 end

 ; if user doesn't want the plan and doesn't provide one,
 ; make sure the plan gets destroyed after use.
 if ~arg_present(plan) then destroyplan = 1

 ; the following types are from the cufft documentation
 ; real to complex   : 0x2a = 42
 ; complex to real   : 0x2c = 44
 ; complex to complex: 0x29 = 41

 case 1 of
    keyword_set(real2complex)     : begin
                    fftType = 42L 
                                    end
    keyword_set(complex2real)     : begin
                    fftType = 44L
                                    end
    keyword_set(complex2complex)  : begin
                    fftType = 41L
                                    end
    else  : begin
               fftType = 42L
               real2complex = 1L
            end
 endcase

 direction = -1L
 if keyword_set(inverse) and ~keyword_set(complex2complex) then begin
   message, level=1, 'gpuFFT: direction only allowed for complex2complex'
 end else begin
   if keyword_set(inverse) then direction = 1L
 end

 if res_gpu.n_elements lt 2*((x_gpu.n_elements / 2) + 1) then begin
    message, level=-1, 'gpuFFT: Insufficient space for result vector'
 end

 if size(plan, /type) eq 0 then begin
   plan = 0L

   if keyword_set(DIM2D) then begin
     err = cufftPlan2d(plan, x_gpu.dimension[0], x_gpu.dimension[1], $
                   fftType)
   end else begin
     if not keyword_set(BATCH) then batch= 1L
     err = cufftPlan1d(plan, x_gpu.n_elements, fftType, long(batch))
   end
 end

 case 1 of
    keyword_set(real2complex): begin
         err = cufftExecR2C(plan, x_gpu.handle, res_gpu.handle)
                               end
    keyword_set(complex2real): begin
         err = cufftExecC2R(plan, x_gpu.handle, res_gpu.handle)
                               end
    keyword_set(complex2complex): begin
         err = cufftExecC2C(plan, x_gpu.handle, res_gpu.handle, direction)
                                  end
  endcase

  if ~keyword_set(denormalized) and ~keyword_set(inverse) then begin
    gpuAdd, 1.0/float(x_gpu.n_elements), res_gpu, 0.0, res_gpu, 0.0, res_gpu
  end

  if keyword_set(destroyplan) then begin
    err = cufftDestroy( plan)
    plan = 0L
  end

end



;---- initialization

;+
; Detects the installed GPU device.
; :Returns: identifier for installed GPU device::
;              1 for GPU hardware
;              0 for pure IDL emulation
;             -1 for GPU hardware emulation
;
;-
function gpuDetectDevice
 catch, deviceError

 dev = 1S

 if deviceError ne 0 then begin
   dev = 0S
   catch, /cancel
 end

 if dev ne 0 then begin
   err = cudaGetDeviceProperties(prop, 0)
   if prop.name eq 'Device Emulation (CPU)' then dev = -1S
 end

 return, dev
end

;+
; Start up the IDL CUDA interface in either: hardware, emulator, or
; IDL mode. Unless a new mode is specfied, uses the previous mode if the CUDA
; interface has already been initialized. Defaults to hardware if no mode is
; specified and CUDA has not already been initialized.
;
; :Keywords:
;    HARDWARE : in, optional, type=boolean
;       set to run GPU library routine in hardware mode
;    EMULATOR : in, optional, type=boolean
;       set to run GPU library routines in emulator mode
;    IDL : in, optional, type=boolean
;       set to run GPU library routines in native IDL mode
;    ERROR : out, optional, type=integer
;       error status
;-
pro gpuinit, HARDWARE=hardware, EMULATOR=emulator, IDL=idl, ERROR=err
  compile_opt strictarr
  on_error, 2

  err = 0

  ; at most one mode can be set
  if (keyword_set(hardware) + keyword_set(emulator) + keyword_set(idl) gt 1) then begin
    message, 'only one of HARDWARE, EMULATOR, or IDL may be set'
  endif

  mode = gpuDetectDevice()

  ;  override detected device if desired
  case 1 of
    keyword_set(hardware) : mode = 1S
    keyword_set(emulator) : mode = -1S
    keyword_set(idl)      : mode = 0S
    else                  : begin
        defsysv, '!gpu', exists=alreadyInitialized
        mode = alreadyInitialized ? !gpu.mode : mode
      end
  endcase

  defsysv, '!gpu', { !gpu, mode: mode }

  if (!gpu.mode ne 0) then err = cublasinit()
end
